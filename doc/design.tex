\documentclass[12pt,letterpaper]{article}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{fullpage}
\usepackage{lastpage}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{mathrsfs}
\usepackage{xfrac}
\usepackage{listings}
\usepackage[margin=3cm]{geometry}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.05in}

% Edit these as appropriate
\newcommand\course{Reenix Design}
\newcommand\yourname{Alexander Light} % <-- your name
\newcommand\login{allight}            % <-- your CS login

%My commands
\newcommand{\field}[1]{\mathbb{#1}}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\xor}{\oplus}
\newcommand{\limplies}{\rightarrow}
\newcommand{\liff}{\leftrightarrow}
\newcommand{\rust}{\texttt{Rust}}

%other stuff

\pagestyle{fancyplain}
\headheight 35pt
\lhead{\yourname\ (\login)}
\chead{\textbf{\Large \course}}
\rhead{\today}
\headsep 10pt

\begin{document}
\lstset{language={[x86masm]Assembler}}
\section{Introduction}

Reenix is the name of a unix-like operating system written in \rust{}
that I am writing. I plan for it to be based on the design of the Weenix
operating system from \texttt{CS167/9} and for it to be useful both as
a measure of how usable \rust{} is in making an operating system and
as a measure of how the use of a higher level language can aid in the
creation of an OS kernel.

\section{Overall Design}
I have split Reenix up into several crates (what most other languages
would call libraries or modules), most of which are similar to the
directories of the Weenix project. The reasons for splitting this up is
partly due to the long compile times of \rust{} and the fact that if I
want to make use of the \rust{} standard library I need some parts of my
system (such as memory allocation) compiled before the standard library
packages are. Each module is created as a standard \rust{} library
package, with a \texttt{lib.rs} file being the base which declares
the dependencies on external crates and declares the interior modules
and exports. This crate is split further up into different files and
sub-directories where appropriate.

I will talk about each of the crates in turn, expanding on the design
of any interesting pieces within them, any strange decisions within the
crate and the reasons for them and what crates each depends upon. I will
also talk about each of the rust standard library crates I am using,
whether I have had to modify them and if so how, and what each of them do.


\subsection{Crate: \texttt{base}}
The \texttt{base} crate holds many of the small, low-level pieces
of Reenix which are needed by almost every other crate. It holds a
definition of errno, the links to some linker variables, as well as a
definition for a \texttt{halt} function. Other than these most of what it
holds are purely utility and helper functions. For example it contains
the whole Reenix debug-printing system, which is used to implement a
\texttt{dbg} macro. There are some other miscellaneous things this crate
holds but none are very interesting. The only thing that really ties
them together is that they are totally separate from the whole rest of
the kernel and are useful in all other modules.

In the future this may declare some \texttt{traits} (something similar to
\texttt{java}'s \texttt{interface}'s) for many of the important pieces
of Reenix in other crates to get around \rust{}'s requirement that
crates have no dependency loops. Alternatively these \texttt{traits}
may end up in their own crate to allow us to make use of the \rust{}
\texttt{collections} and \texttt{alloc} crate within them.

This crate has no dependencies aside from the \rust{} \texttt{core} crate.

\subsection{Crate: \texttt{mm}}
The \texttt{mm} crate holds the implementation of memory management
for Reenix. Currently it is mostly just a translation layer between the
\texttt{C} memory system from Weenix and the \rust{} notion of what memory
management is. It also defines a way for modules to request that specific
sizes of slab allocators be provided, in order to improve allocation speed
and consistency. Finally it has a way to search for the correct slab
to allocate a request for a given amount of memory on. It does this by
allocating a page if it is larger than a certain threshold and otherwise
searching through a tree map it has of all the allocators and their sizes.

Due to the fact that we use the size of objects being allocated and freed
to determine which slab we should use to provide the actual memory we
have a strange restriction that all slabs must be allocated and known
about prior to allocating the first object. Because of this restriction
we have a somewhat strange 2 phase initialization system for the Reenix
as a whole where during phase 1 memory allocation is forbidden (except
through explicit use of kmalloc/kfree). We then go to phase 2 where
memory may be allocated and freed normally.

This crate depends only upon the \texttt{Core} crate and the \rust{}
standard library crates \texttt{core} and \texttt{libc}.

\subsubsection{Challenge: Allocation failure}
One requirement that we must consider is that in general \rust{}
considers memory allocation to never fail. This is, unfortunately,
built rather deeply into their language's standard-library, with few
operations that allocate memory having any way to return that memory
allocation failed.  The standard \rust{} response to an out-of-memory
error is to \texttt{fail!()} the current task.  In a normal \rust{}
runtime this will cause a \texttt{C++} style exception to propagate up
the call stack calling the finalizes of the locals at each level. It
is implemented using the \texttt{Call-Frame-Information} (\texttt{CFI})
exception mechanism popularized by \texttt{C++}. While there do not seem
to be any serious design obstacles with implementing this form of error
handling I do not plan to even attempt to do it. Even in places where
languages implementing this form of exception management are used for
kernel code (such as in the XNU-kernel's \texttt{I/O kit} driver system)
exception handling in this manner is generally forbidden. Furthermore
I do not have any real experience with writing this form of exception
handler, and do not believe that writing this would be very enlightening.

In order to avoid the requirement of writing this complicated exception
handling mechanism I am going to emulate it in the following, somewhat
hacky, manner. Prior to entering the first thread context I will reserve
several (~16) contiguous pages with the page allocator.  These I will use
to create a rather simple free-list based allocator, capable of allocating
page-aligned regions. This will be used as a "backup" allocator for
the normal allocating scheme, if we, for some reason, fail to allocate
using the normal slab and page allocators we will fall back on using
this. However this is not meant to be a real allocator. Instead kernel
code should periodically (especially after known allocations) check with
the memory management system to see if this backup allocator is being
used. If it is the code should act as though the allocation failed.

In order to stop myself from growing to depend on the implementation
detail that, even in the case of a (theoretical) allocation failure,
the memory is really allocated I will implement and use a standard macro
which will make the allocation act as if it was fallible. In Reenix this
will be implemented by running the allocation then afterwards checking if
it is using the backup allocator, deallocating it and returning failure
if so. If either the implementation of \rust{} task failure are ever
changed or \texttt{CFI} based exception handling is implemented this
macro will be swapped out for one that uses that mechanism, if possible.

This is, in just about every way, a temporary hack to get around
the problem. A real-world \rust{} kernel would need to deal with this
directly. Either by patching the rust compiler (as well as much of it's
standard library) to be able to have allocations fail more intelligently
or by implementing this \texttt{CFI} based exception handling.

\subsection{Crate: \texttt{startup}}
The (somewhat confusingly named) \texttt{startup} crate (name provisional)
is a bit of a hodge-podge of Reenix components that do not obviously
belong anywhere else. This crate will likely move into other parts
as their places become clearer. The only part likely to remain in the
\texttt{startup} crate longterm is the \texttt{gdt} support, since this
is needed to setup the stack overflow detection that \rust{} builds into
its language. For much the same reason thread-specific data support
is included here as well, since that is implemented using the memory
segmentation support.

It also currently contains the \texttt{acpi} shim and the \texttt{pci}
shim. These both might end up being moved later as they are implemented in \rust{}.

This crate depends upon the \texttt{base} and \texttt{mm} crates.

\subsection{Crate: \texttt{procs}}
The \texttt{procs} crate holds all the code relating to processes and
threads in Reenix. It holds a definition for KProc, The Reenix process
implementation, as well as KThread and all scheduling and process
switching related code. It also holds the implementation of interrupts
and a (hopefully temporary) shim to initialize the \texttt{apic}. An
implementation of a mutex synchronization primitive is also defined here.

These are all implemented similarly to Weenix but using \rust{} standard
library collections types instead of the interned list approach used
by Weenix.

This crate depends upon the \texttt{base} and \texttt{mm} crates. It
also depends on the \rust{} standard library crates \texttt{alloc}
and \texttt{collections} for smart pointers and collections respectively.

\subsubsection{Advantages of Rust: Pointer safety}
There are several quite nice advantages to using \rust{} to define the
structures and methods needed for procs instead of \texttt{C}. The most obvious
of these is the fact that using \rust{} we get smart pointer data structures.
These make defining (and verifying) the relationships between objects much
easier. For example it means that we now get a free check on memory corruption
since if we can say that each proc's parent pointer is a \texttt{Weak} pointer.
Then when we try to dereference it we get the check that the pointer has not
been freed.

\subsubsection{Module: Context}
The context module defines the context structs that are used to define
the execution context in Reenix. These are defined in much the same way
they are in Weenix, with the only notable difference being that each
context includes a (boxed) thread specific data structure, which keeps
track of information such as the current thread and process.

In large part due to how much simpler it is using the \rust{} collections
types we also implement the run queue in the module, although this
might be changed later. At the moment it is a simple ring buffer holding
pointers to context structs. Unlike in Weenix this runqueue is unrelated
to the waitqueue used in the implementation of mutex's and waiting.

\subsubsection{Module: KQueue}
This module contains an implementation of a condition variable like data
structure. Any number of threads may wait on it and when some thread calls
\texttt{signal} it will wake up all the threads in the queue. Unlike the
weenix version there is no ordering guarantees, with respect to the order
of threads waking up. This is implemented using a \rust{} \texttt{Set}
data structure.

\subsubsection{Module: pcell}
This is a slightly strange module. Basically we have a problem that
depending on which process you are in lifetimes can get slightly
strange. For example to each process their own \texttt{KProc} and
\texttt{KThread} structs should have a \texttt{'static} lifetime, since
they are guaranteed to be there as long as the thread is running. This
is great because it means it should be safe to use them as though they
were static variables and avoid having to pass it around to each and
every function that might possibly need it. This module defines a type
similar to \rust{}'s \texttt{RefCell} data-type, which lets multiple
parts of a program share data with runtime consistency checks. The only
difference between the \texttt{ProcRefCell} defined in the \texttt{pcell}
module is that the pcell gives an escape hatch that is used so that the
current thread (and only the current thread) can consider the contained
value \texttt{'static}, and therefore not to bother with keeping track
of references to it from this thread. We still have the requirement
that other threads not go to sleep while holding onto a reference to
any other thread, which makes this totally safe.

The entire reason this module is necessary is basically that \rust{}
lacks any ability to express this sort of strange lifetime semantics.

\subsection{Crate: \texttt{drivers}}
The \texttt{drivers} crate holds the code related to drivers in Reenix. It
holds implementations for taking in keyboard input, reading/writing from disks
and displaying text on the screen. It may in the future also hold the
\texttt{acpi} and \texttt{pci} implementations instead of \texttt{startup}
(although this is only likely if these are eventually rewritten into \rust{}).

The overall design of the drivers is similar to the Weenix version. At the core
of the crate we have a \texttt{WDevice<T>} and a \texttt{RDevice<T>} trait.
These traits can, respectively, read and write data in chunks of \texttt{T}.
There is also a \texttt{Device<T>} trait which is simply something that is both
these traits.  There are block and byte devices which each define these traits
for \texttt{[u8, .. PAGE\_SIZE]} and \texttt{u8} respectively. These have
implementations for each of the various devices in Weenix. We need to be
careful in here as, since most of the implementation of these structures is
invoked in interrupt handlers we cannot use allocation.  Annoyingly verifying
this is somewhat tricky due to the indirection of \rust{}'s libraries but
realistically we can guarantee this just by checking the code in question and
so is not a huge obstacle. Furthermore this challenge is also present in the
\texttt{C} version of Weenix.

This crate depends on the \texttt{procs} crate to be able to handle interrupts,
as well as the \texttt{collections} and \texttt{alloc} crates.

\subsubsection{Advantages of Rust: \texttt{VTables} and Traits}
A big improvement we will have writing this in \rust{} over \texttt{C} is that
we get the indirection of \texttt{vtables}, which weenix implements manually,
basically for free (at least implementation wise). This makes the
implementation of the drivers somewhat easier as well as makes their use much
less cryptic. Also this language support means we do not need many of the
somewhat magic macros such as \texttt{bd\_to\_ata}. Furthermore we have the
nice advantage that the language itself will check to make sure that all
implementors of these interfaces have all the right functions with the right
types. This makes implementations of new types of drivers somewhat easier.
Furthermore this also makes it somewhat easier to see how we could go about
adding hot-pluggable devices, although no such implementation is attempted in
this project.

\subsubsection{Challenge: Aligned data}
Currently \rust{} has no way of specifying that data should be aligned to any
particular degree. This is annoying because it means I need to basically copy a
structure into memory at a particular alignment for DMA to work, which is very
hacky.  Luckily there are few times where data is required to have a specific
alignment in Reenix so this is not a very large issue. Besides which the fact
that my allocator currently does not really make any guarantees about alignment
would likely kill this feature for heap allocated structures.

\subsubsection{Module: \texttt{bytedev::tty}}
This module contains the implementation for \texttt{TTY}s in Reenix. It is
structured very similarly to the one in weenix, with a line discipline handling
translation from the input chars to the display chars, a virtual terminal
keeping track of whats on the screen, a screen module for actually writing to
the screen, and a keyboard module for taking keyboard input. These are
implemented similarly to weenix but we make use of traits extensively to hide
implementation details from each part. Theoretically it should be easily
possible to replace, for example, the standard line discipline with one that
handles input differently without any of the other parts of the tty noticing.
At the moment, however, no support is included for doing this without
recompiling.

\subsubsection{Module: \texttt{blockdev::disk}}
This module contains the implementation of disk read/write in Reenix. It is
again structured similarly to weenix and uses DMA to control actual access.
Outside of this module all disk access is done only through the \texttt{Device}
trait and so is completely blind to what the actual implementation of disks
are. Like weenix we make no attempt to support slave devices and require the
data we are reading/writing to be placed in page aligned buffers. Unlike weenix
however we have the nice advantage of having much of the bounds checking done
for us. In rust the bounds of an array are always passed along with it to any
functions and so we can be much more sure that we are not accessing or
overwriting uninitialized or unowned memory.

\subsection{Crate: \texttt{fs}}
The \texttt{fs} crate holds an implementation of the VFS subsystem
which implements the common unix file-system contract. This holds an
implementation of \texttt{vnode} and associated entities. This might
also include \texttt{s5fs} (and possibly \texttt{ramfs}) or these might
be in their own crates.

In the future this crate will likely also hold an implementation
of \texttt{pframes}, although that might go in the \texttt{mm} or
\texttt{drivers} crate. The decision on where to put it will likely
depend at least partly on what parts of other crates are needed.

More details about the design and implementation of this crate will be
added as I get closer to implementing it.

\subsection{Crate: \texttt{s5fs}}
The \texttt{s5fs} crate holds an implementation of the s5fs file system
as described by the Weenix documentation. This might end up simply as a
module in the \texttt{fs} crate.

More details about the design and implementation of this crate will be
added as I get closer to implementing it.

\subsection{Crate: \texttt{vm}}
The \texttt{vm} crate holds an implementation of virtual memory for
Reenix, implementing the \texttt{mmap} and \texttt{brk} syscalls and
implementing an anonymous and shadow page subsystem.

More details about the design and implementation of this crate will be
added as I get closer to implementing it.

\subsection{Crate: \texttt{main}}
The \texttt{main} crate holds most of the main method of Reenix. It holds
the main methods for the idle and init processes. It also is what calls
the initialization functions for all other modules and is what brings
the full system up.

\subsection{Standard Crate: \texttt{core}}
The \texttt{core} standard library crate defines many of the basic
data-types needed to write \rust{} code as well as some useful interfaces
and macros for doing things such as formating text. No modifications were
needed to this crate and the one that is built for the standard \rust{}
compiler is used.

\subsection{Standard Crate: \texttt{libc}}
The \texttt{libc} crate declares a large number of \texttt{extern}
functions from the \texttt{C} and \texttt{POSIX} standard libraries as
well as declaring type aliases for them. This is modified to remove most
of the \texttt{POSIX} functions, while leaving the type declarations.

\subsection{Standard Crate: \texttt{alloc}}
The \texttt{alloc} crate declares what \rust{} thinks memory allocation
is and defines some standard smart pointers. It is modified only to
allow it to link with the \texttt{mm} crate to get the memory allocation
from there.

\subsection{Standard Crate: \texttt{collections}}
The \texttt{collections} crate provides implementations for several
standard collection data-types, such as a vector and map.  It is
unmodified and only included in the Reenix source because it inlines
large parts of \texttt{alloc} which is bad since it should be using
my, modified, version of it.

\end{document}

